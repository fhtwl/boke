# 一、前言
具有用户、角色、权限等概念的系统、网站或者项目, 抛开业务功能, 它们本质上都有一个角色权限系统, 这是系统的地基.  

  若依的权限管理系统, 主要有角色管理、菜单管理和用户管理3部分, 每个用户都有自己的角色, 每个角色都有自己的菜单和按钮权限, 这是用户看得到的部分.在用户看不到的地方, 还有角色的接口权限.

  在了解若依权限逻辑后, 用koa2 + Ts和vue + Antdv重构了其角色权限系统
# 二、环境搭建

## 1. 创建包管理文件
``` sh
# 生成package.json
npm init -y
```
新建src文件夹, 在src根目录新建app.ts文件, app.ts就是整个项目的入口

## 2. 安装依赖
``` sh
# 依赖
npm i koa koa-bodyparser koa-router koa-session koa-static koa2-cors log4js mongodb mysql svg-captcha validator ajv ioredis jsonwebtoken
# 依赖注解
npm i --save-dev @types/koa @types/koa-bodyparser @types/koa-router @types/koa-session @types/koa-static @types/koa2-cors @types/log4js @types/mongodb @types/mysql @types/validator @types/ajv @types/ioredis @types/jsonwebtoken

```

## 3. 初始化ts配置
``` sh
# 生成tsconfig.json
tsc --init
```
修改tsconfig.json
``` json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2015",  // 目标语言版本
    "module": "commonjs", // 指定生成代码的模板标准
    "rootDir": "./", // 指定输出目录, 默认是dist文件夹
    "strict": true, // 严格模式
    "allowSyntheticDefaultImports": true, // 没有默认导出时, 编译器会创建一个默认导出
    "esModuleInterop": true, // 允许export= 导出, 由import from导入
    "forceConsistentCasingInFileNames": true // 强制区分大小写 
  },
  "include": [ // 需要编译的的文件和目录
    "src/**/*"
  ],
  "files": [
    "src/app.ts"
  ]
}

```

## 4. 运行项目

在app.ts里实例化一个koa服务器
``` ts
// src/app.ts

// 引入koa
import Koa from 'koa'
import http from 'http'
// 创建koa实例
const app = new Koa()
// 创建服务器
const server: http.Server = new http.Server(app.callback())
// 中间件
app.use(async (ctx) => {
  ctx.body = 'Hello World'
})
// 监听端口
app.listen(9000, () => {
  console.log('run success')
  console.log('app started at port 9000...')
})
```

运行
``` sh
# 编译ts文件
tsc
# 运行编译的文件
node ./dist/src/app.js
```
如果成功的话，命令行会打印
```
run success
app started at port 9000...
```

我们可以在浏览器访问 <a href="http://localhost:9000/">http://localhost:9000/</a> <br/>
此时页面上应该会显示 Hello World <br/>

每次都需要执行编译和运行, 太麻烦, 我们可以在修改package.json, 添加dev命令
``` json
// package.json
{
  ...

  "scripts": {
    "dev": "tsc && node ./dist/src/app.js"
  },
  ...
}

```
之后每次运行npm run dev即可 <br/>
但是这样依然繁琐, 我们希望可以自动监听文件的保存并自动刷新, 这个可以用nodemon和ts-node来实现 <br/>
前者可以监听文件的变更，自动重启服务, 后者可以直接运行ts文件

安装nodemon
``` sh
npm i nodemon ts-node typescript --save-dev
```

修改package.json的dev命令
``` json
// package.json
{

  ...
  "scripts": {
    "dev": "nodemon ./src/app.ts"
  },
  ...
}
```
## 5. 代码风格控制和自动格式化
为了控制代码风格和质量, 我们可以引入eslint和prettier

``` sh
npm i eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-config-prettier prettier --save-dev

```
在根目录创建 .eslintrc.js
``` js
// .eslintrc.js
module.exports = {
  root: true,

  env: {
    node: true,
    es2021: true,
  },

  parser: '@typescript-eslint/parser',

  parserOptions: {
    ecmaVersion: 12,
    sourceType: 'module',
    tsconfigRootDir: __dirname,
    project: ['./tsconfig.json'],
  },

  plugins: ['@typescript-eslint'],
  rules: {
    "@typescript-eslint/no-unsafe-assignment": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "no-useless-escape": "off",
    "@typescript-eslint/no-unsafe-member-access": "off",
    "@typescript-eslint/unbound-method": "off",
    "@typescript-eslint/await-thnable": "off",
    "@typescript-eslint/restrict-template-expressions": "off",
    "@typescript-eslint/no-misused-promises": "off",
    '@typescript-eslint/no-explicit-any': 'off',
    "@typescript-eslint/no-unsafe-call": "off",
    "@typescript-eslint/no-unsafe-argument": "off",
    "no-async-promise-executor": "off",
    "@typescript-eslint/no-floating-promises": "off",
    "@typescript-eslint/require-await": "off",
    "@typescript-eslint/no-var-requires": "off",
    "@typescript-eslint/ban-types": "off",
    "no-prototype-builtins": "off",
    "space-before-function-paren": 0
  },

  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:@typescript-eslint/recommended-requiring-type-checking',
    'prettier',
  ],
}


```
在根目录创建.prettierrc和.editorconfig
``` js
// .prettierrc
{
  "printWidth": 120,
  "semi": false,
  "singleQuote": true,
  "prettier.spaceBeforeFunctionParen": true
}

```

``` sh
# .editorconfig
root = true

[*.{js,ts,json}]
charset=utf-8
end_of_line=lf
insert_final_newline=false
indent_style=space
trim_trailing_whitespace = true
indent_size=2
insert_final_newline = true

```

编辑vscode配置文件setting.json，在末尾添加下列行
``` json
// setting.json
{
  ...
  "eslint.format.enable": true,
  "editor.codeActionsOnSave": {
    // 启用ESLint规则格式化以上设为none的代码
      "source.fixAll.eslint": true
  },
  "editor.tabSize": 2,

  // 保存时格式化代码
  "editor.formatOnSave": true,
  "eslint.trace.server": "off",
  // 粘贴时格式化代码
  "editor.formatOnPaste": false,
  "[typescript]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
}

```

安装vscode插件Prettier - Code formatter <br />

修改src/app.ts, 在末尾添加下列代码

``` ts
// src/app.ts
let a = {
    num: 1
};

```
此时eslint会提示有2个警告1个错误, 代码有3处不符合我们设置的规范
* 'a' is never reassigned. Use 'const' instead.
* num这行应该使用2个空格作为缩进, 而不是4个空格
* 结束行应该没有分号作为结束

当我们ctrl+s保存文件, 会发现编辑器将代码修改为
``` ts
// src/app.ts
const a = {
  num: 1
}
```
不规范的地方被修复了，这表示我们的配置成功了


## 6. 项目编译
在正式环境里部署项目, 我们不再需要对文件修改进行监听, 而是直接编译文件. 因此我们添加一个build命令
``` json
// package.json
{

  ...
  "scripts": {
    "dev": "nodemon ./src/app.ts",
    "build": "tsc && node ./dist/src/app.js"
  },
  ...
}
```

如果项目是部署window环境下, 直接ctrl+c就可以停止项目, 但是如果在linux环境下, 重启项目就比较麻烦, 可以考虑使用pm2来管理node服务

``` sh
# 全局安装pm2
npm install pm2 -g

# 项目根目录
# 运行项目
npm run build

# 查看项目运行状态
pm2 list

# 重启项目
pm2 restart ./dist/src/app.js

```
## 7.环境变量
为了区分正式环境和开发环境, 我们可以使用cross-env添加环境变量
``` sh 
# 安装cross-env
npm i cross-env --save-dev
```

修改dev和build命令
``` json
// package.json
{
  ...
  "scripts": {
    "dev": "cross-env NODE_ENV=development nodemon ./src/app.ts",
    "build": "tsc && cross-env NODE_ENV=production node dist/src/app.js"
  },
  ...
}

```
修改 src/app.ts
``` ts
import Koa from "koa";
import http from "http";
// 创建koa实例
const app = new Koa();
// 创建服务器
const server: http.Server = new http.Server(app.callback());
// 中间件
app.use(async (ctx) => {
  ctx.body = "Hello World";
});
// 监听端口
app.listen(9000, () => {
  console.log("run success");
  console.log("app started at port 9000...");
  console.log(process.env.NODE_ENV);
});

```
我们就能看到控制台打印出来的development。

至此,基础环境搭建基本完成


# 三、中间件开发

## 1. 中间件的含义和作用

中间件是一种封装方式, 用于处理http请求的功能 <br />
如果将一个http请求比喻为一条运水的管道, 那么中间件就是管道上的仪表、阀门等处理装置 <br />
中间件主要有3个核心概念: 请求request、响应response和next函数 <br />
request和response是请求的上下文信息Context, next函数用于控制状态.  <br />
如果一个请求, 没有设置response, 那么这个请求就会返回404  <br />
如果一个请求, 进入某个中间件后, 只有当执行next函数后, 请求才会继续执行下一个中间件. 如果没有执行next函数, 而是设置response的状态码和返回值, 那么请求就会结束, 不再继续执行下面的中间件，而是直接把response返回给前端. <br />

## 2. koa如何使用中间件

koa使用use方法载入中间件
``` ts
// 中间件middleware
const middleware1 = (ctx, next) => {
  console.log('1');
  next();
}
// 中间件middleware2
const middleware2 = (ctx, next) => {
  console.log('2');
  ctx.body = 'hello world'
}
app.use(middleware1)
app.use(middleware2)
```

值得注意的是, 中间件先被use的, 就先执行 <br />

下面我们介绍一些常用的中间件，并开发一些中间件<br />


为了模块清晰, 我们在src目录下创建core文件夹, 用户存放核心静态类 <br />
在src/core目录下, 新建Init.ts, 用于初始化中间件 <br />

## 3. 请求报文处理中间件

http请求里，报文主体（即body参数部分）是以二进制的数据在网络中进行传输，并且为了优化速度，还常常会对内容进行压缩编码，比如gzip <br />
koa-bodyparser中间件，会将post请求的请求报文进行处理，将请求主体以json格式，挂载在ctx.request.body上
``` ts
// src/core/Init.ts

import Koa from 'koa'
import http from 'http'
import koaBodyParser from 'koa-bodyparser'
class Init {
  public static app: Koa<Koa.DefaultState, Koa.DefaultContext>
  public static server: http.Server
  public static initCore(app: Koa<Koa.DefaultState, Koa.DefaultContext>, server: http.Server) {
    Init.app = app
    Init.server = server
    Init.loadBodyParser()
  }

  // 解析body参数
  public static loadBodyParser() {
    Init.app.use(koaBodyParser())
  }
}

export default Init.initCore

```
``` ts
// src/app.ts
import Koa from 'koa'
import http from 'http'
import initCore from './core/Init'
// 创建koa实例
const app = new Koa()
// 创建服务器
const server: http.Server = new http.Server(app.callback())

// 执行初始化
initCore(app, server)
// 监听端口
app.listen(9000, () => {
  console.log('run success')
  console.log('app started at port 9000...')
  console.log(process.env.NODE_ENV)
})

```



## 4. 路由中间件
服务器端路由，即根据不同路径的http请求做出对应的相应和处理
``` ts
// src/core/Init.ts
class Init {
  ...
  static async initLoadRouters() {
    Init.app.use((ctx) => {
      console.log(ctx.path)
      switch (ctx.path) {
        case '/login':
          // 只允许post请求
          if (ctx.method === 'GET') {
            ctx.status = 404
            break
          }
          ctx.body = '登录成功'
          break
        case '/getUser':
          // 只允许get请求
          if (ctx.method === 'POST') {
            ctx.status = 404
            break
          }
          ctx.body = 'admin'
          break
        default: {
          ctx.status = 404
        }
      }
    })
  }
  ...
}
```
但是这样做，所有的处理都在一起，在实际开发中并不合适。我们希望把不同的请求处理函数放在不同的目录和文件里, 并且能方便地设置请求路径和请求方法 <br />
koa-router是koa的一个路由中间件，它可以将请求的URL和方法（如：GET 、 POST 、 PUT 、 DELETE 等） 匹配到对应的响应程序或页面 <br />

在src下新建目录api，在api下新建目录v1，表示接口的版本，当前版本的接口都放在v1目录下 <br />

在v1下新建文件text.ts, 在这个文件里，我们创建一个路由实例
``` ts
// src/api/v1/test.ts
import Router from 'koa-router'
const router = new Router({
  prefix: '/api/v1',
})

router.get('/test', async (ctx) => {
  ctx.body = 'test'
})

export default router

```
然后在init里加载这个路由实例
``` ts
// src/core/Init.ts
import test from '../api/v1/test'
class Init {
  ...
  static async initLoadRouters() {
    Init.app.use(test.routes())
  }
  ...
}
```
目前我们约定，src/api目录下，只存放http请求路由文件，因此手动引动太过繁琐，我们希望可以自动递归遍历src/api目录，自动加载所有的路由处理 <br />

在src目录下新建common目录，用于存放公共文件，在common下新建utils目录，用于存放工具函数，再在utils下新建utils.ts <br />

我们先在utils里写一个遍历目录下所有文件默认导出的方法
``` ts
// src/common/utils/utils.ts

import fs from 'fs'
import path from 'path'
/**
 * 获取某个目录下所有文件的默认导出
 * @param filePath 需要遍历的文件路径
 */
export async function getAllFilesExport(filePath: string, callback: Function) {
  // 根据文件路径读取文件，返回一个文件列表
  const files: string[] = fs.readdirSync(filePath)
  // 遍历读取到的文件列表
  files.forEach((fileName) => {
    // path.join得到当前文件的绝对路径
    const absFilePath: string = path.join(filePath, fileName)
    const stats: fs.Stats = fs.statSync(absFilePath)
    const isFile = stats.isFile() // 是否为文件
    const isDir = stats.isDirectory() // 是否为文件夹
    if (isFile) {
      const file = require(absFilePath)
      callback(file.default)
    }
    if (isDir) {
      getAllFilesExport(absFilePath, callback) // 递归，如果是文件夹，就继续遍历该文件夹里面的文件；
    }
  })
}

```
然后在init里调用
``` ts
// src/core/Init.ts
class Init {
  ...
  static async initLoadRouters() {
    const dirPath = path.join(`${process.cwd()}/src/api/`)
    getAllFilesExport(dirPath, (file: Router) => {
      Init.app.use(file.routes())
    })
  }
  ...
}
```
此时src/api目录下的路由会被自动调用，但是还有一个问题，就是在build后，目录会变化，变成/dist/src/api/，我们需要根据环境变量，控制加载目录 <br />

其它需要使用绝对路径的地方，都会有这个问题，所以我们可以创建一个公共变量，利于复用 <br />

在src下创建目录config, 在config下创建Config.ts， 用于存放配置和公共变量

``` ts
// src/config/Config.ts
const isDev = process.env.NODE_ENV === 'development'

export default class Config {
  // 服务器端口
  public static readonly HTTP_PORT = 9000
  // 接口前缀
  public static readonly API_PREFIX = '/api/'
  // 根目录
  public static readonly BASE = isDev ? 'src' : 'dist/src'
}


```
修改app.ts
``` ts
// src/app.ts
import Koa from 'koa'
import http from 'http'
import initCore from './core/Init'
import Config from './config/Config'
// 创建koa实例
const app = new Koa()
// 创建服务器
const server: http.Server = new http.Server(app.callback())

// 执行初始化
initCore(app, server)
// 监听端口
app.listen(Config.HTTP_PORT, () => {
  console.log('run success')
  console.log(`app started at port ${Config.HTTP_PORT}...`)
  console.log(process.env.NODE_ENV)
})

```
修改src/api/v1/test.ts
``` ts
// src/api/v1/test.ts

import Router from 'koa-router'
import Config from '../../config/Config'
const router = new Router({
  prefix: `${Config.API_PREFIX}v1`, // 路径前缀
})
// 指定一个url和请求方法匹配处理
router
  .get('/test', (ctx) => {
    ctx.body = 'test'
  })
  .post('/login', (ctx) => {
    ctx.body = '登录'
  })

export default router

```

修改src/core/Init.ts
``` ts
// src/core/Init.ts

import Koa from 'koa'
import http from 'http'
import koaBodyParser from 'koa-bodyparser'
import path from 'path'
import { getAllFilesExport } from '../common/utils/utils'
import Router from 'koa-router'
import Config from '../config/Config'
class Init {
  public static app: Koa<Koa.DefaultState, Koa.DefaultContext>
  public static server: http.Server
  public static initCore(app: Koa<Koa.DefaultState, Koa.DefaultContext>, server: http.Server) {
    Init.app = app
    Init.server = server
    Init.loadBodyParser()
    Init.initLoadRouters()
  }

  // 解析body参数
  public static loadBodyParser() {
    Init.app.use(koaBodyParser())
  }

  // http路由加载
  static async initLoadRouters() {
    const dirPath = path.join(`${process.cwd()}/${Config.BASE}/api/`)
    getAllFilesExport(dirPath, (file: Router) => {
      Init.app.use(file.routes())
    })
  }
}

export default Init.initCore

```

## 5. 错误监听和日志处理
koa可以通过ctx.throw()方法或者创建一个Error实例并使用throw关键字直接抛出错误, 错误会中断程序的执行.  <br />
如果错误会被try...catch捕获, 一旦被程序就会执行catch里的语句, 然后继续往下执行. <br />

``` ts
// 中间件one
const one = (ctx, next) => {
  console.log('>> one');
  next();
  console.log('<< one');
}
// 中间件two
const two = (ctx, next) => {
  console.log('>> two');
  next();
  console.log('<< two');
}

app.use(one)
app.use(two)
```
最后的打印结果是
```
>> one
>> two
<< one
<< two
```
ctx的当前的上下文, next有点类型回调函数的意思, 会在执行完next后再执行下一步 <br />
因此, 在第一个中间件里, 用try...catch将next包裹, 就能监听往后所有中间件的错误, 知道给ctx.body赋值, 整个响应结束 <br />
如果我们自定义一些"错误", 当捕获到不同"错误"时, 做出响应的处理, 那这个中间件不仅仅可以捕获异常, 还能给接口响应一个统一的出口. <br />
在src/core目录下，新建HttpException.ts，用于存放不同的http错误类型
``` ts
// src/core/HttpException.ts
// http异常
export class HttpException extends Error {
  public message: string
  public errorCode: number
  public code: number
  public data: any
  public isBuffer = false
  public responseType: string | undefined
  constructor(data = {}, msg = '服务器异常，请联系管理员', errorCode = 10000, code = 400) {
    super()
    this.message = msg
    this.errorCode = errorCode
    this.code = code
    this.data = data
  }
}
// http参数异常
export class ParameterException extends HttpException {
  constructor(msg?: string, errorCode?: number) {
    super()
    this.code = 422
    this.message = msg || '参数错误'
    this.errorCode = errorCode || 10000
  }
}

// http请求成功
export class Success extends HttpException {
  public data
  public responseType
  public session
  constructor(data?: unknown, msg = 'ok', code = 200, errorCode = 0, responseType?: string, session?: string) {
    super()
    this.code = code //200查询成功，201操作成功
    this.message = msg
    this.errorCode = errorCode || 0
    this.data = data
    this.responseType = responseType
    this.session = session
  }
}
// 返回文件流
export class Buffer extends Success {
  public data
  public responseType
  public session
  public isBuffer
  constructor(data?: any, responseType?: string, session?: string) {
    super()
    this.code = 200 //200查询成功，201操作成功
    this.message = 'ok'
    this.errorCode = 0
    this.data = data
    this.responseType = responseType
    this.session = session
    this.isBuffer = true
  }
}
// 404
export class NotFount extends HttpException {
  constructor(msg: string, errorCode: number) {
    super()
    this.code = 404
    this.message = msg || '资源未找到'
    this.errorCode = errorCode || 10001
  }
}
// 授权失败
export class AuthFailed extends HttpException {
  constructor(msg?: string, errorCode?: number) {
    super()
    this.code = 401
    this.message = msg || '授权失败'
    this.errorCode = errorCode || 10002
  }
}
// Forbbiden
export class Forbbiden extends HttpException {
  constructor(msg: string, errorCode?: number) {
    super()
    this.code = 403
    this.message = msg || '禁止访问'
    this.errorCode = errorCode || 100006
  }
}

// 查询失败
export class QueryFailed extends HttpException {
  constructor(msg?: string, errorCode?: number) {
    super()
    this.code = 500
    this.message = msg || '未查到匹配的数据'
    this.errorCode = errorCode || 100006
  }
}

// 查询失败
export class dataBaseFailed extends HttpException {
  constructor(msg?: string, errorCode?: number) {
    super()
    this.code = 500
    this.message = msg || '数据库出错'
    this.errorCode = errorCode || 100005
  }
}

```
当请求过程中，出现一些我们预料之中的情况，比如
* 请求成功应该返回数据
* 请求参数错误或者校验失败
* 请求成功需要返回文件
* 登录失效
...

我们可以抛出错误，并拦截做出处理，返回对应的状态码和数据。<br />

如果是意料之外的错误,则按异常处理, 并打印日志<br />

在src目录下新建目录middlewares，用户存放自定义中间件，然后在middlewares目录下新建catchError.ts，开发错误拦截中间件<br />


``` ts
// src/middlewares/catchError.ts
import koa from 'koa'
import { Success, HttpException } from '../core/HttpException'
export async function catchError(ctx: koa.Context, next: Function) {
  const { method, path } = ctx
  try {
    await next()
  } catch (error: any) {
    // 当前错误是否是我们自定义的Http错误
    const isHttpException = error instanceof HttpException

    // 如果不是, 则抛出错误
    if (!isHttpException) {
      ctx.body = {
        msg: '未知错误',
        errorCode: 9999,
        requestUrl: `${method} ${path}`,
      }
      ctx.status = 500
    }
    // 如果是已知错误
    else {
      if (error.responseType) {
        ctx.response.type = error.responseType
      }
      // 如果是文件流，则直接返回文件
      if (error.isBuffer) {
        ctx.body = error.data
      } else {
        ctx.body = {
          msg: error.message,
          errorCode: error.errorCode,
          data: error.data,
        }
      }

      ctx.status = error.code

    }
  }
}


```
然后再Init里使用中间件

``` ts
// src/core/Init.ts
class Init {

  ...
  Init.initCatchError()
  ...

  ...
  // 错误监听和日志处理
  public static initCatchError() {
    Init.app.use(catchError)
  }

  ...
}

```

我们修改下src/api/v1/test.ts接口，根据不同的请求抛出不同的处理
``` ts
// src/api/v1/test.ts
import { Success, ParameterException, AuthFailed } from '../../core/HttpException'
router
  .get('/test', (ctx) => {
    const { id } = ctx.request.body
    const token = ctx.header['authorization'] || ctx.cookies.get('authorization')
    // 如果没有携带登录信息
    if (!token) {
      throw new AuthFailed('未登录')
    }
    // 如果缺少参数或者参数类型错误
    if (typeof id !== 'number') {
      throw new ParameterException('缺少参数id')
    }
    // 请求成功
    throw new Success('text')
  })
```
打开浏览器访问<a href="http://localhost:9000/api/v1/test">http://localhost:9000/api/v1/test</a>,可以看到接口返回
> {"msg":"未登录","errorCode":10002,"data":{}}

这样当所有的错误, 以及http请求响应,都会集中在catchError中间件中处理,根据我们设置的HttpException返回对应的数据. <br/>

除去控制太和返回客户端的错误信息之外,我们还需要一个日志系统,将错误记录在一个固定目录下,便于日后查看 <br/>

在src/common下创建文件夹lib, 然后新建logs.ts, 用于存放日志配置.我们的日志系统主要依赖于log4js. <br />



在src下新建server目录, 用户存放单例和公共业务<br />
在src/server下, 新建logs目录, 用户存放日志相关的业务<br />
src/server/logs下, 新建logsConfing.ts, 用户存放log4js的配置
``` ts
// src/server/logs/logsConfing.ts
export default {
  appenders: {
    console: {
      type: 'console',
    },
    date: {
      type: 'dateFile',
      filename: 'logs/date',
      category: 'normal',
      alwaysIncludePattern: true,
      pattern: '-yyyy-MM-dd-hh.log',
    },
  },
  categories: {
    default: {
      appenders: ['console', 'date'],
      level: 'info',
    },
  },
}

```
log4js配置项很多, 这里只介绍了appenders和categories配置<br />
* appenders 可以在appenders添加属性设置日志类型.我们这里添加了console和date,并通过type设置记录类型.type为console时,表示记录在控制台;type为dateFile, date表示记录在文件里,并根据时间将日志分片

* categories 通过categories.defult.appenders,可以设置启用的appenders.通过categories.defult.level,可以对日志进行过滤

在src/server/logs目录下, 新建logger.ts, 用于获取logger.  <br />
由于我们的配置, 是在logs目录下新建日期日志, 而logs文件并不需要记录在git版本里, 我们也没有手动创建logs目录. 当代码运行时, 因为logs目录不存在, 就会报错. 所以在服务启动时,需要先判断logs目录是否存在. <br />

``` ts
// src/server/logs/logger.ts
import log4js from 'log4js'
import fs from 'fs'
import { isDirectory } from '../../common/utils/utils'
import logsConfing from './logsConfing'

//检查某个目录是否存在
if (!isDirectory('logs')) {
  fs.mkdirSync('logs')
}

log4js.configure(logsConfing)

const logger = log4js.getLogger('cheese')

export default logger

```

``` ts
// src/common/utils/utils.ts

/**
 * 判断某个文件夹是否存在
 * @param path
 * @returns {boolean}
 */
export function isDirectory(path: string): boolean {
  try {
    const stat = fs.statSync(path)
    return stat.isDirectory()
  } catch (error) {
    return false
  }
}
```
日志的内容, 除去错误信息外, 我们还希望知道错误是调用哪个接口产生的, 因此我们还需要拿到上下文信息Context, 即请求信息和响应信息. Context使用的频率很高, 我们可以将这些常用的类型整合起来 <br />
在src/common目录下, 新建typings目录, 用于存放公共的描述文件 <br />
在src/common/typings下, 新建model.d.ts
``` ts
import Koa from 'koa'
export namespace Models {
  type Ctx = Koa.Context
}
```

然后在src/server/logs目录下, 创建index.ts, 用于封装具体业务
``` ts
// src/server/logs/index.ts
import logger from './logger'
import { Models } from '../../common/typings/model'

/**
 * 记录信息日志
 * @param ctx
 */
export function infoLog(ctx: Models.Ctx) {
  const { method, response, originalUrl } = ctx
  logger.info(method, response.status, originalUrl)
}

/**
 * 记录错误日志
 * @param ctx
 * @param error
 */
export function errorLog(ctx: Models.Ctx, error: any) {
  const { method, response, originalUrl } = ctx
  logger.error(method, response.status, originalUrl, error)
}
```

然后在catchError中间件里,我们引入logger
``` ts
import logger from '../common/lib/logs'
export default async function catchError(ctx: koa.Context, next: Function) {
  const { method, path } = ctx
  try {
    await next()
  } catch (error: any) {
    // 当前错误是否是我们自定义的Http错误
    const isHttpException = error instanceof HttpException

    // 如果不是, 则抛出错误
    if (!isHttpException) {
      logger.error(method, ctx.response.status, ctx.originalUrl, error)
      ...
    }
    // 如果是已知错误
    else {
      ...
      if (error instanceof Success || error instanceof Buffer) {
        logger.info(method, ctx.response.status, ctx.originalUrl)
      } else {
        logger.error(method, ctx.response.status, ctx.originalUrl, error)
      }
    }
  }
}

```
当服务重启后，我们可以看到，项目自动在根目录生成了logs文件夹和date.-2022-05-05-13.log（名称就是当前时间），在当我们调用接口时,就能在logs里看到日志文件date.-2022-05-05-13.log内容更新了
``` log
[2022-05-05T13:41:54.102] [ERROR] cheese - GET 401 /api/v1/test AuthFailed [Error]: 未登录
    at F:\code\git-demo\node\demo\src\api\v1\test.ts:14:13
    at dispatch (F:\code\git-demo\node\demo\node_modules\koa-compose\index.js:42:32)
    at F:\code\git-demo\node\demo\node_modules\koa-router\lib\router.js:372:16
    at dispatch (F:\code\git-demo\node\demo\node_modules\koa-compose\index.js:42:32)
    at F:\code\git-demo\node\demo\node_modules\koa-compose\index.js:34:12
    at dispatch (F:\code\git-demo\node\demo\node_modules\koa-router\lib\router.js:377:31)
    at dispatch (F:\code\git-demo\node\demo\node_modules\koa-compose\index.js:42:32)
    at F:\code\git-demo\node\demo\src\middlewares\catchError.ts:6:11
    at Generator.next (<anonymous>)
    at F:\code\git-demo\node\demo\src\middlewares\catchError.ts:8:71 {
  isBuffer: false,
  errorCode: 10002,
  code: 401,
  data: undefined
}

```
# 四、引入数据库

## 1. Redis

在上一部分的日志处理中, 如果我们需要日志系统, 比如可以在前端展示日志的列表, 或者查看最新的报错信息, 如果采用读取log文件的方式, 效率比较低, 我们可以考虑将报错的日志存储在Redis里, 便于读取, 也方便设置日志的过期时间 <br />

在src/server下, 新建redis目录, 在redis下新建redisConfing.ts, 用于存放配置文件
``` ts
// src/server/redis/redisConfing.ts
export default {
  port: 6379, // Redis port
  host: '127.0.0.1', // Redis host
  password: 'admin',
  db: 0,
}

```
在src/server/redis下新建redis.ts, 创建redis实例
``` ts
// src/server/redis/redis.ts
import redisConfing from './redisConfing'
import IoreDis from 'IoreDis'
export default new IoreDis(redisConfing)
```
在src/server/redis下新建index.ts, 用于封装常用方法和公共业务
