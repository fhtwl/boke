--- 
title: nodejs + koa2 + ts + mysql + redis + vue 重构若依后台管理系统角色权限设计
date: 2022-04-25
categories: 
 - 后端
tags: 
 - nodejs
 - vue.js
 - mysql
 - redis
 - koa2
---

## 前言
  具有用户、角色、权限等概念的系统、网站或者项目, 抛开业务功能, 它们本质上都有一个角色权限系统, 这是系统的地基.  

  若依的权限管理系统, 主要有角色管理、菜单管理和用户管理3部分, 每个用户都有自己的角色, 每个角色都有自己的菜单和按钮权限, 这是用户看得到的部分.在用户看不到的地方, 还有角色的接口权限.

  在了解若依权限逻辑后, 用koa2 + Ts和vue + Antdv重构了其角色权限系统

## 项目开发

### 1. 前端

  前端部分我主要是使用antdv pro去实现.
  主要有token, 动态路由, v-action(控制按钮显示隐藏的自定义指令), 具体内容可以参考<a href="https://pro.antdv.com/docs/authority-management">Antdv Pro官网</a>

### 2. 后端

#### 数据库设计
   
1. mysql

  数据库建表主要有角色表role, 菜单表menu, 用户表user等.
  * 每一个用户user都有一个角色id <b>role_id</b>;
  * 每一个角色role都有一个权限的集合字段 <b>permissions</b>, 这个集合里包含该角色拥有的所有权限id(以逗号分隔的id字符串);
  * 每个角色都拥有父级角色 <b>parent_id</b>, 角色的权限可继承, 即每个角色的权限等于自己权限和自己所有祖宗角色权限的并集;
  * 角色的权限体现在菜单分类、菜单、按钮的操作权限和接口的访问权限上, 这些都保存在菜单表menu的记录里, 角色role的权限的集合字段 <b>permissions</b>的数据即是多条menu的<b>id</b>的集合, 通过 <b>type</b>字段区分菜单分类、菜单和按钮, 每个菜单(即页面)和按钮都有自己的权限标识 <b>permission</b>, 通过权限标识来控制菜单的接口和按钮的接口访问权限, 以及按钮在前端的操作权限;
  * menu表的记录分为分类、菜单和按钮, 每个menu都有父级 <b>parent_id</b>, 分类的父级只能是分类, 菜单的父级只能是分类, 按钮的父级只能菜单.通过父子关系, 就能组合成改角色的前端路由

2. redis

  redis主要用来缓存token和角色
  * token以字符串类型保存, 以token为key, userId作为值
  * 角色以hash类型保存, 每一个角色都是一个对象, 角色id作为key, 每个值里有<b>id</b>、<b>parentId</b>, 和<b>permission</b>, 通过id和parentId确定角色的父子关系, 通过permission保存该角色的权限标识, 通过权限标识来判断该该角色是否可以访问某个接口
#### 目录介绍
  <p><img src="/images/nodejs/目录.jpg"></p>
  src<br />
    + api 存放接口<br />
    + common 公共资源 <br />
      + apiValidate 接口参数json配置, 配置每个接口参数的数据类型等  <br />
      + lib 常量等  <br />
      + typings 类型声明  <br />
      + utils 工具函数  <br />
    + config 系统配置, 数据库配置等 <br />
    + core 核心静态类 <br />
      + HttpException http异常  <br />
      + Init 项目初始化入口 <br />
      + MongoDB MongoDB封装 <br />
      + Mysql Mysql封装 <br />
      + Redis 封装  <br />
    + middlewares 中间件  <br />
      + Auth 用户认证相关中间件, 校验token是否合法, 权限是否满足  <br />
      + Code 验证码校验中间件  <br />
      + exception 全局异常监听和处理中间件  <br />
      + logs 日志中间件  <br />
      + Security 安全中间件 限制ip访问次数等  <br />
      + Upload 文件上传中间件  <br />
      + validator 接口请求参数json校验中间件  <br />
    + public 静态资源目录  <br />
    + service 公共业务  <br />
    + app.ts 入口文件
      
#### 代码实现

1. 使用koa2创建web服务器
  
``` ts
// src/app.ts

// 引入koa
import Koa from 'koa'
// 引入初始化方法
import initCore from './core/Init'
import http from 'http'
import Config from './config/config'
// 创建koa实例
const app = new Koa()
// 创建服务器
const server: http.Server = new http.Server(app.callback())
// 执行初始化
initCore(app, server)
// 监听端口
app.listen(Config.http_port, () => {
  console.log('run success')
  console.log(`app started at port ${Config.http_port}...`)
})
```

2. 初始化跨域, 接口监听, 错误监听和日志处理, redis缓存, 静态资源服务, session等

``` ts
// src/core/Init.ts
import Koa from 'koa'
import errors from './HttpException'
import { catchError } from '../middlewares/exception'
import path from 'path'
import staticFiles from 'koa-static'
import cors from 'koa2-cors'
import { fileDisplay } from '../common/utils/Utils'
import session from 'koa-session'
import Config from '../config/config'
import http from 'http'
import Security from '../middlewares/security'
import SocketService from '../service/socket/index'
import Auth from '../middlewares/Auth'
import koaBodyParser from 'koa-bodyparser'
class Init {
  public static app: Koa<Koa.DefaultState, Koa.DefaultContext>
  public static server: http.Server
  public static initCore(app: Koa<Koa.DefaultState, Koa.DefaultContext>, server: http.Server) {
    Init.app = app
    Init.server = server
    Init.loadBodyParser()
    Init.loadCrossDomain()
    Init.initCatchError()
    Init.loadStatic()
    Init.loadSession()
    Init.initLoadRouters()
    Init.loadSocket()
    Init.updateRedisRole()
  }

  // 解析body参数
  public static loadBodyParser() {
    Init.app.use(koaBodyParser())
  }

  // 错误监听和日志处理
  public static initCatchError() {
    Init.app.use(catchError)
  }

  // 创建静态资源服务
  public static loadStatic() {
    Init.app.use(staticFiles(path.join(`${process.cwd()}/src/public/`)))
  }

  // 跨域处理
  static loadCrossDomain() {
    Init.app.use(cors())
  }

  // 加载接口
  static async initLoadRouters() {
    const dirPath = path.join(`${process.cwd()}/${Config.base}/api/`)
    await fileDisplay(dirPath, Init.app)
    console.log('接口加载完成')
  }

  // 加载session
  static loadSession() {
    Init.app.keys = ['some secret hurr']
    Init.app.use(
      session(
        {
          key: 'koa:sess', //cookie key (default is koa:sess)
          maxAge: 86400000, // cookie的过期时间 maxAge in ms (default is 1 days)
          overwrite: true, //是否可以overwrite    (默认default true)
          httpOnly: true, //cookie是否只有服务器端可以访问 httpOnly or not (default true)
          signed: true, //签名默认true
          rolling: false, //在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）
          renew: false, //(boolean) renew session when session is nearly expired,
        },
        Init.app
      )
    )
  }

  // 更新redis里的角色数据
  public static updateRedisRole() {
    Auth.updateRedisRole()
  }
}

export default Init.initCore

```

3. mysql封装

3. 登录和token

在用户登录后, 服务端创建一个令牌, 并返回给前端, 前端在请求后端时携带这个令牌, 服务端通过比对这个令牌, 就可以确定用户的身份, 避免请求中携带用户敏感信息导致的泄露, 也避免了频繁查询数据库获取用户密码造成的资源浪费.这个令牌就是token.   
为了保证token的安全性, 我们需要将token加密并缓存下来, 并设置过期时间
``` ts
// src/api/v1/system/auth/login.ts

import { Models } from '../../../../common/typings/model'
import KoaRouter from 'koa-router'
import Mysql from '../../../../core/Mysql'
import { Success, ParameterException } from '../../../../core/HttpException'
import validator from '../../../../middlewares/validator'
import { generateToken } from '../../../../common/utils/Utils'
import login from '../../../../common/apiValidate/system/auth/login'
import Config from '../../../../config/config'
import RedisClient from '../../../../core/Redis'

const router = new KoaRouter({
  prefix: `${Config.api_prefix}system/auth`,
})


router.post('/login', 
  validator(login, 'body'), // 校验body参数是否符合要求
  checkCode, // 校验存储与session的验证码
  async (ctx) => {
    const { email, password, userName } = ctx.request.body
    const res: Models.Result = await Mysql.command(`
          SELECT
          id,email,deleted,info,password,role_id
          FROM
              user
          where
              user.user_name = '${name}'
      `)
    const {
      user, token
    } = getToken(res, password)
    // Success 继承于 Error, 通过
    throw new Success({ user, token })
  }
)



function getToken(res: Models.Result, password: string) {
  if (!res.error) {
    const user = res.results[0]
    const correct = checkPassword(password, user.password as string)
    if (!correct) {
      throw new ParameterException('密码不正确')
    }
    const token = generateToken(user.id as number, user.roleId)
    RedisClient.saveToken(token, user.id)
    return {
      token,
      user,
    }
  }
}



export default router

``` 


3. 校验中间件开发

``` ts

```

4. 给接口添加权限校验中间件. 

有些接口不需要任何权限, 如登录, 有些接口需要登录权限, 就需要校验token, 有些接口需要对应的菜单权限和操作权限, 就需要校验角色权限


  后端部分主要通过mysql去存储对应的角色和权限, 并使用redis做缓存. 

  主要流程:  
  * 当用户登录时保存生成token
  



## 代码实现

### 1. 前端

### 2. 后端

* 在服务启动时, 从mysql里拉取角色相关数据, 并存在redis里

``` ts

export default class Auth {
  /**
   * 获取用户权限
   * @param decode
   * @returns
   */
  static async getUserPermission(decode: Decode): Promise<Menu.Menu[]> {
    const { scope } = decode
    return new Promise(async (resolve, reject) => {
      let res: Models.Result

      try {
        res = await Mysql.command(`
            SELECT
              permissions
            FROM
              role
            where
              id = ${scope}
        `)
        if (!res.error) {
          const user = res.results[0]
          if (user) {
            const menuList: Menu.Menu[] = (
              await Mysql.command(`
                SELECT
                  permission
                FROM
                  menu
                WHERE
                  FIND_IN_SET(
                  id,
                  '${user.permissions}')
              `)
            ).results
            resolve(menuList)
          } else {
            resolve([])
          }
        } else {
          reject()
        }
      } catch (error) {
        console.log(error)
        reject()
      }
    })
  }
  /**
   * 获取所有角色的权限列表
   * @returns
   */
  static async getAllRolePermission(): Promise<Role[]> {
    return new Promise(async (resolve, reject) => {
      let res: Models.Result
      try {
        res = await Mysql.command(`
            SELECT
              id,
              permissions,
              parent_id parentId,
              name
            FROM
              role
        `)
        if (!res.error) {
          const menuList: Role[] = []
          for (let i = 0; i < res.results.length; i++) {
            const item: Menu.Menu = res.results[i]
            menuList.push({
              id: item.id,
              parentId: item.parentId,
              name: item.name,
              menuList: await Auth.getUserPermission({
                scope: item.id,
                uid: 0,
              }),
            })
          }
          resolve(menuList)
        } else {
          reject()
        }
      } catch (error) {
        reject()
      }
    })
  }

  /**
   * 更新redis里的角色
   */
  static updateRedisRole() {
    Auth.getAllRolePermission().then((list) => {
      list.forEach((res) => {
        if (res.menuList.length > 0) {
          redisClient.updateRoles(
            (res.id || '').toString(),
            new Map([
              ['id', res.id.toString()],
              ['parentId', res.parentId.toString()],
              ['permissions', res.menuList.map((item) => item.permission).join(',')],
            ])
          )
        }
      })
    })
  }
}
```

* 权限校验中间件开发

``` ts
export default class Auth {
  /**
   * 校验token
   * @param ctx
   * @param next
   * @param callback
   */
  static async verifyToken(ctx: Models.Ctx, next: Koa.Next, callback?: Function) {
    //检测token是否合法
    const userToken = Auth.getToken(ctx)
    let errMsg = 'token不合法'
    if (!userToken) {
      throw new Forbbiden('无访问权限')
    }
    const uid = (await redisClient.getTokenValue(userToken)).results
    let decode
    try {
      // 解析token
      decode = jwt.verify(userToken, config.security.secretKey) as string | Decode
    } catch (error) {
      if (error && (error as Error)?.name == 'TokenExpiredError') {
        errMsg = 'token已过期'
        throw new AuthFailed(errMsg)
      }
      throw new Forbbiden(errMsg)
    }
    if (typeof decode === 'object') {
      if (uid != decode.uid) {
        errMsg = 'token已过期'
        throw new AuthFailed(errMsg, 401)
      }
      // 保存uid和scope
      ctx.auth = {
        uid: decode.uid,
        scope: decode.scope,
      }
      if (callback) {
        await callback(decode)
      }
    } else {
      errMsg = '权限不足'
      throw new Forbbiden(errMsg)
    }
    await next()
  }

  /**
   * 获取token
   * @param ctx
   * @returns
   */
  static getToken(ctx: Models.Ctx) {
    return ctx.header['authorization'] || ctx.cookies.get('authorization')
  }

  /**
   * 校验token权限
   * @param ctx
   * @param next
   */
  static async verifyTokenPermission(ctx: Models.Ctx, next: Koa.Next) {
    await Auth.verifyToken(ctx, next, async (decode: Decode) => {
      const permissionList: string[] = await Auth.getRedisUserPermission(decode)

      const bool = permissionList.find((permission) => {
        const path = `${config.api_prefix}${permission.split(':').join('/')}`
        return path === ctx.path
      })
      if (!bool) {
        throw new Forbbiden('权限不足')
      }
    })
  }
}
```


* 为接口添加校验中间件

``` ts
const router = new KoaRouter({
  prefix: `${Config.api_prefix}system/user`,
})

/**
 * 编辑密码
 */
router.post(
  '/editPassword', 
  Auth.verifyTokenPermission, 
  validator(editPassword, 'body'),
  checkCode,
  async (ctx: Models.Ctx) => {
    const id = ctx.auth?.uid
    const { password, emailCode } = ctx.request.body
    if (ctx.session!.emailCode !== emailCode) {
      throw new ParameterException('邮箱验证码错误')
    }
    await Mysql.command(`
      UPDATE
        user
      SET password = '${password}'
      WHERE id = ${id}
  `)
    throw new Success()
  }
)

```

#### 2. 目录结构
  src下
    + api 接口目录
    + common
    

##### 校验流程
  * 服务启动时, 查询mysql数据库查询所有角色并存入redis里
  * 当用户登录后, 后端根据用户的id和角色id生成token保存在redis里, 并设置过期时间, 然后返回给前端
  * 给需要校验的接口加上校验中间件
  * 首先去redis里校验请求里携带的token是否有效, 无效则返回401. 有效则继续在查询redis里角色数据, 并解析token拿到角色id, 来获取






